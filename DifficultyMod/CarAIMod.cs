// Generated by .NET Reflector from C:\Projects\Skylines\DifficultyMod\DifficultyMod\libs\Assembly-CSharp.dll
using ColossalFramework;
using ColossalFramework.Math;
using System;
using System.Runtime.InteropServices;
using UnityEngine;

public class CarAIMod : VehicleAI
{
    private static bool CalculateCrossing(NetInfo segmentInfo, ushort segmentID, ref NetSegment segmentData, ushort nodeID, out Vector3 position, out Vector3 direction, out float radius)
    {
        NetManager instance = Singleton<NetManager>.instance;
        position = Vector3.zero;
        direction = Vector3.zero;
        uint lanes = segmentData.m_lanes;
        float num2 = 0f;
        radius = 0f;
        for (int i = 0; (i < segmentInfo.m_lanes.Length) && (lanes != 0); i++)
        {
            if (segmentInfo.m_lanes[i].m_laneType == (NetInfo.LaneType.None | NetInfo.LaneType.Vehicle))
            {
                if (segmentData.m_startNode == nodeID)
                {
                    position += instance.m_lanes.m_buffer[lanes].m_bezier.a;
                    direction += instance.m_lanes.m_buffer[lanes].m_bezier.a - instance.m_lanes.m_buffer[lanes].m_bezier.b;
                }
                else
                {
                    position += instance.m_lanes.m_buffer[lanes].m_bezier.d;
                    direction += instance.m_lanes.m_buffer[lanes].m_bezier.d - instance.m_lanes.m_buffer[lanes].m_bezier.c;
                }
                num2++;
                radius = Mathf.Max(radius, Mathf.Abs(segmentInfo.m_lanes[i].m_position) + (segmentInfo.m_lanes[i].m_width * 0.5f));
            }
            lanes = instance.m_lanes.m_buffer[lanes].m_nextLane;
        }
        if (num2 != 0f)
        {
            position = (Vector3)(position / num2);
            direction = VectorUtils.NormalizeXZ(direction);
            return true;
        }
        return false;
    }

    private static float CalculateMaxSpeed(float targetDistance, float targetSpeed, float maxBraking)
    {
        float num = 0.5f * maxBraking;
        float num2 = num + targetSpeed;
        return (Mathf.Sqrt(Mathf.Max((float)0f, (float)((num2 * num2) + ((2f * targetDistance) * maxBraking)))) - num);
    }

    protected override void CalculateSegmentPosition(ushort vehicleID, ref Vehicle vehicleData, PathUnit.Position position, uint laneID, byte offset, out Vector3 pos, out Vector3 dir, out float maxSpeed)
    {
        NetManager instance = Singleton<NetManager>.instance;
        instance.m_lanes.m_buffer[laneID].CalculatePositionAndDirection(offset * 0.003921569f, out pos, out dir);
        NetInfo info = instance.m_segments.m_buffer[position.m_segment].Info;
        if ((info.m_lanes != null) && (info.m_lanes.Length > position.m_lane))
        {
            maxSpeed = this.CalculateTargetSpeed(vehicleID, ref vehicleData, info.m_lanes[position.m_lane].m_speedLimit, instance.m_lanes.m_buffer[laneID].m_curve);
        }
        else
        {
            maxSpeed = this.CalculateTargetSpeed(vehicleID, ref vehicleData, 1f, 0f);
        }
    }

    protected override void CalculateSegmentPosition(ushort vehicleID, ref Vehicle vehicleData, PathUnit.Position nextPosition, PathUnit.Position position, uint laneID, byte offset, PathUnit.Position prevPos, uint prevLaneID, byte prevOffset, out Vector3 pos, out Vector3 dir, out float maxSpeed)
    {
        NetManager instance = Singleton<NetManager>.instance;
        instance.m_lanes.m_buffer[laneID].CalculatePositionAndDirection(offset * 0.003921569f, out pos, out dir);
        Vehicle.Frame lastFrameData = vehicleData.GetLastFrameData();
        Vector3 a = lastFrameData.m_position;
        Vector3 b = instance.m_lanes.m_buffer[prevLaneID].CalculatePosition(prevOffset * 0.003921569f);
        float num = ((0.5f * lastFrameData.m_velocity.sqrMagnitude) / base.m_info.m_braking) + (base.m_info.m_generatedInfo.m_size.z * 0.5f);
        if (Vector3.Distance(a, b) >= (num - 1f))
        {
            Segment3 segment;
            ushort startNode;
            ushort endNode;
            ushort num4;
            segment.a = pos;
            if (offset < position.m_offset)
            {
                segment.b = (Vector3)(pos + (dir.normalized * base.m_info.m_generatedInfo.m_size.z));
                startNode = instance.m_segments.m_buffer[position.m_segment].m_startNode;
                endNode = instance.m_segments.m_buffer[position.m_segment].m_endNode;
            }
            else
            {
                segment.b = (Vector3)(pos - (dir.normalized * base.m_info.m_generatedInfo.m_size.z));
                startNode = instance.m_segments.m_buffer[position.m_segment].m_endNode;
                endNode = instance.m_segments.m_buffer[position.m_segment].m_startNode;
            }
            if (prevOffset == 0)
            {
                num4 = instance.m_segments.m_buffer[prevPos.m_segment].m_startNode;
            }
            else
            {
                num4 = instance.m_segments.m_buffer[prevPos.m_segment].m_endNode;
            }
            if (startNode == num4)
            {
                NetNode.Flags flags = instance.m_nodes.m_buffer[startNode].m_flags;
                NetLane.Flags flags2 = (NetLane.Flags)instance.m_lanes.m_buffer[prevLaneID].m_flags;
                bool flag = (flags & NetNode.Flags.TrafficLights) != NetNode.Flags.None;
                bool flag2 = (flags & NetNode.Flags.LevelCrossing) != NetNode.Flags.None;
                bool flag3 = (flags2 & NetLane.Flags.JoinedJunction) != NetLane.Flags.None;
                if (((flags & (NetNode.Flags.OneWayIn | NetNode.Flags.OneWayOut | NetNode.Flags.Junction)) == NetNode.Flags.Junction) && (instance.m_nodes.m_buffer[startNode].CountSegments() != 2))
                {
                    float len = vehicleData.CalculateTotalLength(vehicleID) + 2f;
                    if (!instance.m_lanes.m_buffer[laneID].CheckSpace(len))
                    {
                        bool flag4 = false;
                        if (((nextPosition.m_segment != 0) && (instance.m_lanes.m_buffer[laneID].m_length < 30f)) && (((instance.m_nodes.m_buffer[endNode].m_flags & (NetNode.Flags.OneWayIn | NetNode.Flags.OneWayOut | NetNode.Flags.Junction)) != NetNode.Flags.Junction) || (instance.m_nodes.m_buffer[endNode].CountSegments() == 2)))
                        {
                            uint index = PathManager.GetLaneID(nextPosition);
                            if (index != 0)
                            {
                                flag4 = instance.m_lanes.m_buffer[index].CheckSpace(len);
                            }
                        }
                        if (!flag4)
                        {
                            maxSpeed = 0f;
                            return;
                        }
                    }
                }
                if (flag && (!flag3 || flag2))
                {
                    RoadBaseAI.TrafficLightState state;
                    RoadBaseAI.TrafficLightState state2;
                    bool flag5;
                    bool flag6;
                    uint currentFrameIndex = Singleton<SimulationManager>.instance.m_currentFrameIndex;
                    uint num8 = (uint)((num4 << 8) / 0x8000);
                    uint num9 = (currentFrameIndex - num8) & 0xff;
                    NetInfo info = instance.m_nodes.m_buffer[startNode].Info;
                    RoadBaseAI.GetTrafficLightState(num4, ref instance.m_segments.m_buffer[prevPos.m_segment], currentFrameIndex - num8, out state, out state2, out flag5, out flag6);
                    if (!flag5 && (num9 >= 0xc4))
                    {
                        flag5 = true;
                        RoadBaseAI.SetTrafficLightState(num4, ref instance.m_segments.m_buffer[prevPos.m_segment], currentFrameIndex - num8, state, state2, flag5, flag6);
                    }
                    if (((vehicleData.m_flags & Vehicle.Flags.Emergency2) == Vehicle.Flags.None) || (info.m_class.m_service != ItemClass.Service.Road))
                    {
                        switch (state)
                        {
                            case RoadBaseAI.TrafficLightState.IsChanging:
                                if (num9 >= 60)
                                {
                                    break;
                                }
                                maxSpeed = 0f;
                                return;

                            case RoadBaseAI.TrafficLightState.Red:
                                maxSpeed = 0f;
                                return;

                            case RoadBaseAI.TrafficLightState.GreenToRed:
                                if (num9 < 30)
                                {
                                    break;
                                }
                                maxSpeed = 0f;
                                return;
                        }
                    }
                }
            }
        }
        NetInfo info2 = instance.m_segments.m_buffer[position.m_segment].Info;
        if ((info2.m_lanes != null) && (info2.m_lanes.Length > position.m_lane))
        {
            maxSpeed = this.CalculateTargetSpeed(vehicleID, ref vehicleData, info2.m_lanes[position.m_lane].m_speedLimit, instance.m_lanes.m_buffer[laneID].m_curve);
        }
        else
        {
            maxSpeed = this.CalculateTargetSpeed(vehicleID, ref vehicleData, 1f, 0f);
        }
    }

    protected Vector4 CalculateTargetPoint(Vector3 refPos, Vector3 targetPos, float maxSqrDistance, float speed)
    {
        Vector4 vector2;
        Vector3 vector = targetPos - refPos;
        float sqrMagnitude = vector.sqrMagnitude;
        if (sqrMagnitude > maxSqrDistance)
        {
            vector2 = (Vector4)(refPos + (vector * Mathf.Sqrt(maxSqrDistance / sqrMagnitude)));
        }
        else
        {
            vector2 = targetPos;
        }
        vector2.w = speed;
        return vector2;
    }

    private ushort CheckCitizen(Segment3 segment, float lastLen, float nextLen, ref float maxSpeed, ref bool blocked, float maxBraking, ushort otherID, ref CitizenInstance otherData, Vector3 min, Vector3 max)
    {
        float num;
        float num2;
        CitizenInfo info = otherData.Info;
        CitizenInstance.Frame lastFrameData = otherData.GetLastFrameData();
        Vector3 position = lastFrameData.m_position;
        Vector3 vector2 = lastFrameData.m_position + lastFrameData.m_velocity;
        Segment3 segment2 = new Segment3(position, vector2);
        Vector3 vector3 = segment2.Min();
        vector3.x -= info.m_radius;
        vector3.z -= info.m_radius;
        Vector3 vector4 = segment2.Max();
        vector4.x += info.m_radius;
        vector4.y += info.m_height;
        vector4.z += info.m_radius;
        if ((((min.x < (vector4.x + 1f)) && (min.y < vector4.y)) && ((min.z < (vector4.z + 1f)) && (vector3.x < (max.x + 1f)))) && (((vector3.y < (max.y + 2f)) && (vector3.z < (max.z + 1f))) && (segment.DistanceSqr(segment2, out num, out num2) < ((1f + info.m_radius) * (1f + info.m_radius)))))
        {
            float targetDistance = lastLen + (nextLen * num);
            if (targetDistance >= 0.01f)
            {
                targetDistance -= 2f;
                float b = Mathf.Max(1f, CalculateMaxSpeed(targetDistance, 0f, maxBraking));
                maxSpeed = Mathf.Min(maxSpeed, b);
            }
        }
        return otherData.m_nextGridInstance;
    }

    private ushort CheckOtherVehicle(ushort vehicleID, ref Vehicle vehicleData, ref Vehicle.Frame frameData, ref float maxSpeed, ref bool blocked, ref Vector3 collisionPush, float maxBraking, ushort otherID, ref Vehicle otherData, Vector3 min, Vector3 max, int lodPhysics)
    {
        if (((otherID != vehicleID) && (vehicleData.m_leadingVehicle != otherID)) && (vehicleData.m_trailingVehicle != otherID))
        {
            Vector3 vector;
            Vector3 vector2;
            if (lodPhysics >= 2)
            {
                vector = otherData.m_segment.Min();
                vector2 = otherData.m_segment.Max();
            }
            else
            {
                vector = Vector3.Min(otherData.m_segment.Min(), (Vector3)otherData.m_targetPos3);
                vector2 = Vector3.Max(otherData.m_segment.Max(), (Vector3)otherData.m_targetPos3);
            }
            if ((((min.x < (vector2.x + 2f)) && (min.y < (vector2.y + 2f))) && ((min.z < (vector2.z + 2f)) && (vector.x < (max.x + 2f)))) && ((vector.y < (max.y + 2f)) && (vector.z < (max.z + 2f))))
            {
                Vehicle.Frame lastFrameData = otherData.GetLastFrameData();
                VehicleInfo info = otherData.Info;
                if (lodPhysics < 2)
                {
                    float num;
                    float num2;
                    float num3 = vehicleData.m_segment.DistanceSqr(otherData.m_segment, out num, out num2);
                    if (num3 < 4f)
                    {
                        Vector3 vector3 = vehicleData.m_segment.Position(0.5f);
                        Vector3 vector4 = otherData.m_segment.Position(0.5f);
                        Vector3 vector5 = vehicleData.m_segment.b - vehicleData.m_segment.a;
                        if (Vector3.Dot(vector5, vector3 - vector4) < 0f)
                        {
                            collisionPush = (Vector3)(collisionPush - (vector5.normalized * (0.1f - (num3 * 0.025f))));
                        }
                        else
                        {
                            collisionPush = (Vector3)(collisionPush + (vector5.normalized * (0.1f - (num3 * 0.025f))));
                        }
                        blocked = true;
                    }
                }
                float num4 = frameData.m_velocity.magnitude + 0.01f;
                float magnitude = lastFrameData.m_velocity.magnitude;
                float num6 = (magnitude * (0.5f + ((0.5f * magnitude) / info.m_braking))) + Mathf.Min(1f, magnitude);
                magnitude += 0.01f;
                float num7 = 0f;
                Vector3 b = vehicleData.m_segment.b;
                Vector3 lhs = vehicleData.m_segment.b - vehicleData.m_segment.a;
                for (int i = 0; i < 4; i++)
                {
                    Vector3 targetPos = (Vector3)vehicleData.GetTargetPos(i);
                    Vector3 rhs = targetPos - b;
                    if (Vector3.Dot(lhs, rhs) > 0f)
                    {
                        float num9 = rhs.magnitude;
                        Segment3 segment = new Segment3(b, targetPos);
                        min = segment.Min();
                        max = segment.Max();
                        segment.a.y *= 0.5f;
                        segment.b.y *= 0.5f;
                        if ((((num9 > 0.01f) && (min.x < (vector2.x + 2f))) && ((min.y < (vector2.y + 2f)) && (min.z < (vector2.z + 2f)))) && (((vector.x < (max.x + 2f)) && (vector.y < (max.y + 2f))) && (vector.z < (max.z + 2f))))
                        {
                            float num10;
                            Vector3 a = otherData.m_segment.a;
                            a.y *= 0.5f;
                            if (segment.DistanceSqr(a, out num10) < 4f)
                            {
                                float targetSpeed = Vector3.Dot(lastFrameData.m_velocity, rhs) / num9;
                                float targetDistance = num7 + (num9 * num10);
                                if (targetDistance >= 0.01f)
                                {
                                    targetDistance -= targetSpeed + 3f;
                                    float num13 = Mathf.Max(0f, CalculateMaxSpeed(targetDistance, targetSpeed, maxBraking));
                                    if (num13 < 0.01f)
                                    {
                                        blocked = true;
                                    }
                                    Vector3 vector11 = Vector3.Normalize(((Vector3)otherData.m_targetPos0) - otherData.m_segment.a);
                                    float num14 = 1.2f - (1f / ((vehicleData.m_blockCounter * 0.02f) + 0.5f));
                                    if (Vector3.Dot(rhs, vector11) > (num14 * num9))
                                    {
                                        maxSpeed = Mathf.Min(maxSpeed, num13);
                                    }
                                }
                                break;
                            }
                            if (lodPhysics < 2)
                            {
                                float num15 = 0f;
                                float maxLength = num6;
                                Vector3 vector12 = otherData.m_segment.b;
                                Vector3 vector13 = otherData.m_segment.b - otherData.m_segment.a;
                                bool flag = false;
                                for (int j = 0; (j < 4) && (maxLength > 0.1f); j++)
                                {
                                    Vector3 vector15 = Vector3.ClampMagnitude(((Vector3)otherData.GetTargetPos(j)) - vector12, maxLength);
                                    if (Vector3.Dot(vector13, vector15) > 0f)
                                    {
                                        Vector3 vector14 = vector12 + vector15;
                                        float num18 = vector15.magnitude;
                                        maxLength -= num18;
                                        Segment3 segment2 = new Segment3(vector12, vector14);
                                        segment2.a.y *= 0.5f;
                                        segment2.b.y *= 0.5f;
                                        if (num18 > 0.01f)
                                        {
                                            float num19;
                                            float num20;
                                            float num21;
                                            if (otherID < vehicleID)
                                            {
                                                num21 = segment2.DistanceSqr(segment, out num20, out num19);
                                            }
                                            else
                                            {
                                                num21 = segment.DistanceSqr(segment2, out num19, out num20);
                                            }
                                            if (num21 < 4f)
                                            {
                                                float num22 = num7 + (num9 * num19);
                                                float num23 = (num15 + (num18 * num20)) + 0.1f;
                                                if ((num22 >= 0.01f) && ((num22 * magnitude) > (num23 * num4)))
                                                {
                                                    float num24 = Vector3.Dot(lastFrameData.m_velocity, rhs) / num9;
                                                    if (num22 >= 0.01f)
                                                    {
                                                        num22 -= (num24 + 1f) + otherData.Info.m_generatedInfo.m_size.z;
                                                        float num25 = Mathf.Max(0f, CalculateMaxSpeed(num22, num24, maxBraking));
                                                        if (num25 < 0.01f)
                                                        {
                                                            blocked = true;
                                                        }
                                                        maxSpeed = Mathf.Min(maxSpeed, num25);
                                                    }
                                                }
                                                flag = true;
                                                break;
                                            }
                                        }
                                        vector13 = vector15;
                                        num15 += num18;
                                        vector12 = vector14;
                                    }
                                }
                                if (flag)
                                {
                                    break;
                                }
                            }
                        }
                        lhs = rhs;
                        num7 += num9;
                        b = targetPos;
                    }
                }
            }
        }
        return otherData.m_nextGridVehicle;
    }

    private void CheckOtherVehicles(ushort vehicleID, ref Vehicle vehicleData, ref Vehicle.Frame frameData, ref float maxSpeed, ref bool blocked, ref Vector3 collisionPush, float maxDistance, float maxBraking, int lodPhysics)
    {
        Vector3 vector = ((Vector3)vehicleData.m_targetPos3) - frameData.m_position;
        Vector3 rhs = frameData.m_position + Vector3.ClampMagnitude(vector, maxDistance);
        Vector3 min = Vector3.Min(vehicleData.m_segment.Min(), rhs);
        Vector3 max = Vector3.Max(vehicleData.m_segment.Max(), rhs);
        VehicleManager instance = Singleton<VehicleManager>.instance;
        int num = Mathf.Max((int)(((min.x - 10f) / 32f) + 270f), 0);
        int num2 = Mathf.Max((int)(((min.z - 10f) / 32f) + 270f), 0);
        int num3 = Mathf.Min((int)(((max.x + 10f) / 32f) + 270f), 0x21b);
        int num4 = Mathf.Min((int)(((max.z + 10f) / 32f) + 270f), 0x21b);
        for (int i = num2; i <= num4; i++)
        {
            for (int j = num; j <= num3; j++)
            {
                ushort otherID = instance.m_vehicleGrid[(i * 540) + j];
                int num8 = 0;
                while (otherID != 0)
                {
                    otherID = this.CheckOtherVehicle(vehicleID, ref vehicleData, ref frameData, ref maxSpeed, ref blocked, ref collisionPush, maxBraking, otherID, ref instance.m_vehicles.m_buffer[otherID], min, max, lodPhysics);
                    if (++num8 > 0x4000)
                    {
                        CODebugBase<LogChannel>.Error(LogChannel.Core, "Invalid list detected!\n" + System.Environment.StackTrace);
                        break;
                    }
                }
            }
        }
        if (lodPhysics == 0)
        {
            CitizenManager manager2 = Singleton<CitizenManager>.instance;
            float lastLen = 0f;
            Vector3 b = vehicleData.m_segment.b;
            Vector3 lhs = vehicleData.m_segment.b - vehicleData.m_segment.a;
            for (int k = 0; k < 4; k++)
            {
                Vector3 targetPos = (Vector3)vehicleData.GetTargetPos(k);
                Vector3 vector8 = targetPos - b;
                if (Vector3.Dot(lhs, vector8) > 0f)
                {
                    float magnitude = vector8.magnitude;
                    if (magnitude > 0.01f)
                    {
                        Segment3 segment = new Segment3(b, targetPos);
                        min = segment.Min();
                        max = segment.Max();
                        int num12 = Mathf.Max((int)(((min.x - 3f) / 8f) + 1080f), 0);
                        int num13 = Mathf.Max((int)(((min.z - 3f) / 8f) + 1080f), 0);
                        int num14 = Mathf.Min((int)(((max.x + 3f) / 8f) + 1080f), 0x86f);
                        int num15 = Mathf.Min((int)(((max.z + 3f) / 8f) + 1080f), 0x86f);
                        for (int m = num13; m <= num15; m++)
                        {
                            for (int n = num12; n <= num14; n++)
                            {
                                ushort num18 = manager2.m_citizenGrid[(m * 0x870) + n];
                                int num19 = 0;
                                while (num18 != 0)
                                {
                                    num18 = this.CheckCitizen(segment, lastLen, magnitude, ref maxSpeed, ref blocked, maxBraking, num18, ref manager2.m_instances.m_buffer[num18], min, max);
                                    if (++num19 > 0x10000)
                                    {
                                        CODebugBase<LogChannel>.Error(LogChannel.Core, "Invalid list detected!\n" + System.Environment.StackTrace);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    lhs = vector8;
                    lastLen += magnitude;
                    b = targetPos;
                }
            }
        }
    }

    private static bool CheckOverlap(Segment3 segment, ushort ignoreVehicle, float maxVelocity)
    {
        VehicleManager instance = Singleton<VehicleManager>.instance;
        Vector3 vector = segment.Min();
        Vector3 vector2 = segment.Max();
        int num = Mathf.Max((int)(((vector.x - 10f) / 32f) + 270f), 0);
        int num2 = Mathf.Max((int)(((vector.z - 10f) / 32f) + 270f), 0);
        int num3 = Mathf.Min((int)(((vector2.x + 10f) / 32f) + 270f), 0x21b);
        int num4 = Mathf.Min((int)(((vector2.z + 10f) / 32f) + 270f), 0x21b);
        bool overlap = false;
        for (int i = num2; i <= num4; i++)
        {
            for (int j = num; j <= num3; j++)
            {
                ushort otherID = instance.m_vehicleGrid[(i * 540) + j];
                int num8 = 0;
                while (otherID != 0)
                {
                    otherID = CheckOverlap(segment, ignoreVehicle, maxVelocity, otherID, ref instance.m_vehicles.m_buffer[otherID], ref overlap);
                    if (++num8 > 0x4000)
                    {
                        CODebugBase<LogChannel>.Error(LogChannel.Core, "Invalid list detected!\n" + System.Environment.StackTrace);
                        break;
                    }
                }
            }
        }
        return overlap;
    }

    private static ushort CheckOverlap(Segment3 segment, ushort ignoreVehicle, float maxVelocity, ushort otherID, ref Vehicle otherData, ref bool overlap)
    {
        float num;
        float num2;
        if (((ignoreVehicle == 0) || (((otherID != ignoreVehicle) && (otherData.m_leadingVehicle != ignoreVehicle)) && (otherData.m_trailingVehicle != ignoreVehicle))) && ((segment.DistanceSqr(otherData.m_segment, out num, out num2) < 4f) && (otherData.GetLastFrameData().m_velocity.sqrMagnitude < (maxVelocity * maxVelocity))))
        {
            overlap = true;
        }
        return otherData.m_nextGridVehicle;
    }

    private static bool DisableCollisionCheck(ushort vehicleID, ref Vehicle vehicleData)
    {
        if ((vehicleData.m_flags & Vehicle.Flags.Arriving) != Vehicle.Flags.None)
        {
            float a = Mathf.Abs(vehicleData.m_targetPos3.x);
            float num = Mathf.Max(a, Mathf.Abs(vehicleData.m_targetPos3.z));
            float num2 = 8640f;
            if (num > (num2 - 100f))
            {
                return true;
            }
        }
        return false;
    }

    public override void FrameDataUpdated(ushort vehicleID, ref Vehicle vehicleData, ref Vehicle.Frame frameData)
    {
        Vector3 vector = frameData.m_position + ((Vector3)(frameData.m_velocity * 0.5f));
        Vector3 vector2 = (Vector3)(frameData.m_rotation * new Vector3(0f, 0f, Mathf.Max((float)0.5f, (float)((base.m_info.m_generatedInfo.m_size.z * 0.5f) - 1f))));
        vehicleData.m_segment.a = vector - vector2;
        vehicleData.m_segment.b = vector + vector2;
    }

    protected override void InvalidPath(ushort vehicleID, ref Vehicle vehicleData, ushort leaderID, ref Vehicle leaderData)
    {
        vehicleData.m_targetPos0 = vehicleData.m_targetPos3;
        vehicleData.m_targetPos1 = vehicleData.m_targetPos3;
        vehicleData.m_targetPos2 = vehicleData.m_targetPos3;
        vehicleData.m_targetPos3.w = 0f;
        base.InvalidPath(vehicleID, ref vehicleData, leaderID, ref leaderData);
    }

    protected virtual bool IsHeavyVehicle()
    {
        return false;
    }

    protected virtual void PathfindFailure(ushort vehicleID, ref Vehicle data)
    {
        data.Unspawn(vehicleID);
    }

    protected virtual void PathfindSuccess(ushort vehicleID, ref Vehicle data)
    {
    }

    public override void SimulationStep(ushort vehicleID, ref Vehicle data, Vector3 physicsLodRefPos)
    {
        int num2;
        if ((data.m_flags & Vehicle.Flags.WaitingPath) != Vehicle.Flags.None)
        {
            byte pathFindFlags = Singleton<PathManager>.instance.m_pathUnits.m_buffer[data.m_path].m_pathFindFlags;
            if ((pathFindFlags & 4) == 0)
            {
                if ((pathFindFlags & 8) != 0)
                {
                    data.m_flags &= ~Vehicle.Flags.WaitingPath;
                    Singleton<PathManager>.instance.ReleasePath(data.m_path);
                    data.m_path = 0;
                    this.PathfindFailure(vehicleID, ref data);
                    return;
                }
            }
            else
            {
                data.m_pathPositionIndex = 0xff;
                data.m_flags &= ~Vehicle.Flags.WaitingPath;
                data.m_flags &= ~Vehicle.Flags.Arriving;
                this.PathfindSuccess(vehicleID, ref data);
                this.TrySpawn(vehicleID, ref data);
            }
        }
        else if ((data.m_flags & Vehicle.Flags.WaitingSpace) != Vehicle.Flags.None)
        {
            this.TrySpawn(vehicleID, ref data);
        }
        Vector3 lastFramePosition = data.GetLastFramePosition();
        if (Vector3.SqrMagnitude(physicsLodRefPos - lastFramePosition) >= 1210000f)
        {
            num2 = 2;
        }
        else if (Vector3.SqrMagnitude(Singleton<SimulationManager>.instance.m_simulationView.m_position - lastFramePosition) >= 250000f)
        {
            num2 = 1;
        }
        else
        {
            num2 = 0;
        }
        this.SimulationStep(vehicleID, ref data, vehicleID, ref data, num2);
        if ((data.m_leadingVehicle == 0) && (data.m_trailingVehicle != 0))
        {
            VehicleManager instance = Singleton<VehicleManager>.instance;
            ushort trailingVehicle = data.m_trailingVehicle;
            int num4 = 0;
            while (trailingVehicle != 0)
            {
                ushort num5 = instance.m_vehicles.m_buffer[trailingVehicle].m_trailingVehicle;
                instance.m_vehicles.m_buffer[trailingVehicle].Info.m_vehicleAI.SimulationStep(trailingVehicle, ref instance.m_vehicles.m_buffer[trailingVehicle], vehicleID, ref data, num2);
                trailingVehicle = num5;
                if (++num4 > 0x4000)
                {
                    CODebugBase<LogChannel>.Error(LogChannel.Core, "Invalid list detected!\n" + System.Environment.StackTrace);
                    break;
                }
            }
        }
        
        int num6 = 0xff; //(base.m_info.m_class.m_service > ItemClass.Service.Office) ? 150 : 100;
        if (((data.m_flags & (Vehicle.Flags.WaitingSpace | Vehicle.Flags.WaitingPath | Vehicle.Flags.Spawned)) == Vehicle.Flags.None) && (data.m_cargoParent == 0))
        {

            Singleton<VehicleManager>.instance.ReleaseVehicle(vehicleID);
        }
        else if (data.m_blockCounter == num6)
        {
            //Singleton<EconomyManager>.instance.FetchResource(EconomyManager.Resource.Construction, 50, ItemClass.Service.Education, ItemClass.SubService.None, ItemClass.Level.None);
            Singleton<VehicleManager>.instance.ReleaseVehicle(vehicleID);
        }
    }

    public override void SimulationStep(ushort vehicleID, ref Vehicle vehicleData, ref Vehicle.Frame frameData, ushort leaderID, ref Vehicle leaderData, int lodPhysics)
    {
        float w;
        uint currentFrameIndex = Singleton<SimulationManager>.instance.m_currentFrameIndex;
        frameData.m_position += (Vector3)(frameData.m_velocity * 0.5f);
        frameData.m_swayPosition += (Vector3)(frameData.m_swayVelocity * 0.5f);
        float acceleration = base.m_info.m_acceleration;
        float braking = base.m_info.m_braking;
        float magnitude = frameData.m_velocity.magnitude;
        Vector3 v = ((Vector3)vehicleData.m_targetPos0) - frameData.m_position;
        float sqrMagnitude = v.sqrMagnitude;
        float maxDistance = ((magnitude + acceleration) * (0.5f + ((0.5f * (magnitude + acceleration)) / braking))) + (base.m_info.m_generatedInfo.m_size.z * 0.5f);
        float num7 = Mathf.Max((float)(magnitude + acceleration), (float)5f);
        if ((lodPhysics >= 2) && (((currentFrameIndex >> 4) & 3) == (vehicleID & 3)))
        {
            num7 *= 2f;
        }
        float num8 = Mathf.Max((float)((maxDistance - num7) / 3f), (float)1f);
        float minSqrDistanceA = num7 * num7;
        float minSqrDistanceB = num8 * num8;
        int index = 0;
        bool flag = false;
        if (((sqrMagnitude < minSqrDistanceA) || (vehicleData.m_targetPos3.w < 0.01f)) && ((leaderData.m_flags & (Vehicle.Flags.Stopped | Vehicle.Flags.WaitingPath)) == Vehicle.Flags.None))
        {
            if (leaderData.m_path != 0)
            {
                base.UpdatePathTargetPositions(vehicleID, ref vehicleData, frameData.m_position, ref index, 4, minSqrDistanceA, minSqrDistanceB);
                if ((leaderData.m_flags & Vehicle.Flags.Spawned) == Vehicle.Flags.None)
                {
                    frameData = vehicleData.m_frame0;
                    return;
                }
            }
            if ((leaderData.m_flags & Vehicle.Flags.WaitingPath) == Vehicle.Flags.None)
            {
                while (index < 4)
                {
                    float num12;
                    Vector3 targetPos;
                    if (index == 0)
                    {
                        num12 = minSqrDistanceA;
                        targetPos = frameData.m_position;
                        flag = true;
                    }
                    else
                    {
                        num12 = minSqrDistanceB;
                        targetPos = (Vector3)vehicleData.GetTargetPos(index - 1);
                    }
                    int num13 = index;
                    this.UpdateBuildingTargetPositions(vehicleID, ref vehicleData, targetPos, leaderID, ref leaderData, ref index, num12);
                    if (index == num13)
                    {
                        break;
                    }
                }
                if (index != 0)
                {
                    Vector4 pos = vehicleData.GetTargetPos(index - 1);
                    while (index < 4)
                    {
                        vehicleData.SetTargetPos(index++, pos);
                    }
                }
            }
            v = ((Vector3)vehicleData.m_targetPos0) - frameData.m_position;
            sqrMagnitude = v.sqrMagnitude;
        }
        if ((leaderData.m_path != 0) && ((leaderData.m_flags & Vehicle.Flags.WaitingPath) == Vehicle.Flags.None))
        {
            PathUnit.Position position;
            NetManager instance = Singleton<NetManager>.instance;
            byte pathPositionIndex = leaderData.m_pathPositionIndex;
            byte lastPathOffset = leaderData.m_lastPathOffset;
            if (pathPositionIndex == 0xff)
            {
                pathPositionIndex = 0;
            }
            float num16 = 1f + leaderData.CalculateTotalLength(leaderID);
            PathManager manager2 = Singleton<PathManager>.instance;
            if (manager2.m_pathUnits.m_buffer[leaderData.m_path].GetPosition(pathPositionIndex >> 1, out position))
            {
                instance.m_segments.m_buffer[position.m_segment].AddTraffic(Mathf.RoundToInt(num16 * 2.5f));
                bool flag2 = false;
                if (((pathPositionIndex & 1) == 0) || (lastPathOffset == 0))
                {
                    uint laneID = PathManager.GetLaneID(position);
                    if (laneID != 0)
                    {
                        Vector3 b = instance.m_lanes.m_buffer[laneID].CalculatePosition(position.m_offset * 0.003921569f);
                        float num18 = (((0.5f * magnitude) * magnitude) / base.m_info.m_braking) + (base.m_info.m_generatedInfo.m_size.z * 0.5f);
                        if (Vector3.Distance(frameData.m_position, b) >= (num18 - 1f))
                        {
                            instance.m_lanes.m_buffer[laneID].ReserveSpace(num16);
                            flag2 = true;
                        }
                    }
                }
                if (!flag2 && manager2.m_pathUnits.m_buffer[leaderData.m_path].GetNextPosition(pathPositionIndex >> 1, out position))
                {
                    uint num19 = PathManager.GetLaneID(position);
                    if (num19 != 0)
                    {
                        instance.m_lanes.m_buffer[num19].ReserveSpace(num16);
                    }
                }
            }
            if (((currentFrameIndex >> 4) & 15) == (leaderID & 15))
            {
                bool flag3 = false;
                uint path = leaderData.m_path;
                int num21 = pathPositionIndex >> 1;
                for (int i = 0; i < 5; i++)
                {
                    bool flag4;
                    if (PathUnit.GetNextPosition(ref path, ref num21, out position, out flag4))
                    {
                        uint num23 = PathManager.GetLaneID(position);
                        if ((num23 != 0) && !instance.m_lanes.m_buffer[num23].CheckSpace(num16))
                        {
                            continue;
                        }
                    }
                    if (flag4)
                    {
                        this.InvalidPath(vehicleID, ref vehicleData, leaderID, ref leaderData);
                    }
                    flag3 = true;
                    break;
                }
                if (!flag3)
                {
                    vehicleData.m_blockCounter = (byte)Mathf.Min(vehicleData.m_blockCounter + 5, 0xff);
                }
            }
        }
        if ((leaderData.m_flags & Vehicle.Flags.Stopped) != Vehicle.Flags.None)
        {
            w = 0f;
        }
        else
        {
            w = vehicleData.m_targetPos0.w;
        }
        Quaternion quaternion = Quaternion.Inverse(frameData.m_rotation);
        v = (Vector3)(quaternion * v);
        Vector3 vector5 = (Vector3)(quaternion * frameData.m_velocity);
        Vector3 forward = Vector3.forward;
        Vector3 zero = Vector3.zero;
        Vector3 collisionPush = Vector3.zero;
        float f = 0f;
        float num26 = 0f;
        bool blocked = false;
        float len = 0f;
        if (sqrMagnitude > 1f)
        {
            forward = VectorUtils.NormalizeXZ(v, out len);
            if (len > 1f)
            {
                float num29;
                Vector3 vector9 = v;
                num7 = Mathf.Max(magnitude, 2f);
                minSqrDistanceA = num7 * num7;
                if (sqrMagnitude > minSqrDistanceA)
                {
                    vector9 = (Vector3)(vector9 * (num7 / Mathf.Sqrt(sqrMagnitude)));
                }
                bool flag6 = false;
                if (vector9.z < Mathf.Abs(vector9.x))
                {
                    if (vector9.z < 0f)
                    {
                        flag6 = true;
                    }
                    float num28 = Mathf.Abs(vector9.x);
                    if (num28 < 1f)
                    {
                        vector9.x = Mathf.Sign(vector9.x);
                        if (vector9.x == 0f)
                        {
                            vector9.x = 1f;
                        }
                        num28 = 1f;
                    }
                    vector9.z = num28;
                }
                forward = VectorUtils.NormalizeXZ(vector9, out num29);
                len = Mathf.Min(len, num29);
                float curve = 1.570796f * (1f - forward.z);
                if (len > 1f)
                {
                    curve /= len;
                }
                float targetDistance = len;
                if (vehicleData.m_targetPos0.w < 0.1f)
                {
                    w = Mathf.Min(this.CalculateTargetSpeed(vehicleID, ref vehicleData, 1000f, curve), CalculateMaxSpeed(targetDistance, Mathf.Min(vehicleData.m_targetPos0.w, vehicleData.m_targetPos1.w), braking * 0.9f));
                }
                else
                {
                    w = Mathf.Min(Mathf.Min(w, this.CalculateTargetSpeed(vehicleID, ref vehicleData, 1000f, curve)), CalculateMaxSpeed(targetDistance, vehicleData.m_targetPos1.w, braking * 0.9f));
                }
                targetDistance += VectorUtils.LengthXZ((Vector3)(vehicleData.m_targetPos1 - vehicleData.m_targetPos0));
                w = Mathf.Min(w, CalculateMaxSpeed(targetDistance, vehicleData.m_targetPos2.w, braking * 0.9f));
                targetDistance += VectorUtils.LengthXZ((Vector3)(vehicleData.m_targetPos2 - vehicleData.m_targetPos1));
                w = Mathf.Min(w, CalculateMaxSpeed(targetDistance, vehicleData.m_targetPos3.w, braking * 0.9f));
                targetDistance += VectorUtils.LengthXZ((Vector3)(vehicleData.m_targetPos3 - vehicleData.m_targetPos2));
                if (vehicleData.m_targetPos3.w < 0.01f)
                {
                    targetDistance = Mathf.Max((float)0f, (float)(targetDistance - (base.m_info.m_generatedInfo.m_size.z * 0.5f)));
                }
                w = Mathf.Min(w, CalculateMaxSpeed(targetDistance, 0f, braking * 0.9f));
                if (!DisableCollisionCheck(leaderID, ref leaderData))
                {
                    this.CheckOtherVehicles(vehicleID, ref vehicleData, ref frameData, ref w, ref blocked, ref collisionPush, maxDistance, braking * 0.9f, lodPhysics);
                }
                if (flag6)
                {
                    w = -w;
                }
                if (w < magnitude)
                {
                    float num32 = Mathf.Max(acceleration, Mathf.Min(braking, magnitude));
                    f = Mathf.Max(w, magnitude - num32);
                }
                else
                {
                    float num33 = Mathf.Max(acceleration, Mathf.Min(braking, -magnitude));
                    f = Mathf.Min(w, magnitude + num33);
                }
            }
        }
        else if (((magnitude < 0.1f) && flag) && this.ArriveAtDestination(leaderID, ref leaderData))
        {
            leaderData.Unspawn(leaderID);
            if (leaderID == vehicleID)
            {
                frameData = leaderData.m_frame0;
            }
            return;
        }
        if (((leaderData.m_flags & Vehicle.Flags.Stopped) == Vehicle.Flags.None) && (w < 0.03f))
        {
            blocked = true;
        }
        if (blocked)
        {
                vehicleData.m_blockCounter = (byte)Mathf.Min(vehicleData.m_blockCounter + 1, 0xff);            
        }
        else
        {
            vehicleData.m_blockCounter = 0;
        }
        if (len > 1f)
        {
            num26 = Mathf.Asin(forward.x) * Mathf.Sign(f);
            zero = (Vector3)(forward * f);
        }
        else
        {
            f = 0f;
            Vector3 vector10 = Vector3.ClampMagnitude(((Vector3)(v * 0.5f)) - vector5, braking);
            zero = vector5 + vector10;
        }
        bool flag7 = ((currentFrameIndex + leaderID) & 0x10) != 0;
        Vector3 vector11 = zero - vector5;
        Vector3 vector12 = (Vector3)(frameData.m_rotation * zero);
        frameData.m_velocity = vector12 + collisionPush;
        frameData.m_position += (Vector3)(frameData.m_velocity * 0.5f);
        frameData.m_swayVelocity = (Vector3)(((frameData.m_swayVelocity * (1f - base.m_info.m_dampers)) - (vector11 * (1f - base.m_info.m_springs))) - (frameData.m_swayPosition * base.m_info.m_springs));
        frameData.m_swayPosition += (Vector3)(frameData.m_swayVelocity * 0.5f);
        frameData.m_steerAngle = num26;
        frameData.m_travelDistance += zero.z;
        frameData.m_lightIntensity.x = 5f;
        frameData.m_lightIntensity.y = (vector11.z >= -0.1f) ? 0.5f : 5f;
        frameData.m_lightIntensity.z = ((num26 >= -0.1f) || !flag7) ? 0f : 5f;
        frameData.m_lightIntensity.w = ((num26 <= 0.1f) || !flag7) ? 0f : 5f;
        if ((((vehicleData.m_flags & Vehicle.Flags.Parking) != Vehicle.Flags.None) && (len <= 1f)) && flag)
        {
            Vector3 vector13 = (Vector3)(vehicleData.m_targetPos1 - vehicleData.m_targetPos0);
            if (vector13.sqrMagnitude > 0.01f)
            {
                frameData.m_rotation = Quaternion.LookRotation(vector13);
            }
        }
        else if (f > 0.1f)
        {
            if (vector12.sqrMagnitude > 0.01f)
            {
                frameData.m_rotation = Quaternion.LookRotation(vector12);
            }
        }
        else if ((f < -0.1f) && (vector12.sqrMagnitude > 0.01f))
        {
            frameData.m_rotation = Quaternion.LookRotation(-vector12);
        }
        base.SimulationStep(vehicleID, ref vehicleData, ref frameData, leaderID, ref leaderData, lodPhysics);
    }

    protected override bool StartPathFind(ushort vehicleID, ref Vehicle vehicleData, Vector3 startPos, Vector3 endPos)
    {
        return this.StartPathFind(vehicleID, ref vehicleData, startPos, endPos, true, true);
    }

    protected virtual bool StartPathFind(ushort vehicleID, ref Vehicle vehicleData, Vector3 startPos, Vector3 endPos, bool startBothWays, bool endBothWays)
    {
        PathUnit.Position position;
        PathUnit.Position position2;
        PathUnit.Position position3;
        PathUnit.Position position4;
        float num;
        float num2;
        float num3;
        float num4;
        VehicleInfo info = base.m_info;
        if (PathManager.FindPathPosition(startPos, ItemClass.Service.Road, NetInfo.LaneType.None | NetInfo.LaneType.Vehicle, info.m_vehicleType, 32f, out position, out position2, out num, out num2) && PathManager.FindPathPosition(endPos, ItemClass.Service.Road, NetInfo.LaneType.None | NetInfo.LaneType.Vehicle, info.m_vehicleType, 32f, out position3, out position4, out num3, out num4))
        {
            uint num5;
            if (!startBothWays || (num < 10f))
            {
                position2 = new PathUnit.Position();
            }
            if (!endBothWays || (num3 < 10f))
            {
                position4 = new PathUnit.Position();
            }
            if (Singleton<PathManager>.instance.CreatePath(out num5, ref Singleton<SimulationManager>.instance.m_randomizer, Singleton<SimulationManager>.instance.m_currentBuildIndex, position, position2, position3, position4, NetInfo.LaneType.None | NetInfo.LaneType.Vehicle, info.m_vehicleType, 20000f, this.IsHeavyVehicle(), this.IgnoreBlocked(vehicleID, ref vehicleData), false, false))
            {
                if (vehicleData.m_path != 0)
                {
                    Singleton<PathManager>.instance.ReleasePath(vehicleData.m_path);
                }
                vehicleData.m_path = num5;
                vehicleData.m_flags |= Vehicle.Flags.WaitingPath;
                return true;
            }
        }
        return false;
    }

    public override bool TrySpawn(ushort vehicleID, ref Vehicle vehicleData)
    {
        if ((vehicleData.m_flags & Vehicle.Flags.Spawned) == Vehicle.Flags.None)
        {
            if (CheckOverlap(vehicleData.m_segment, 0, 1000f))
            {
                vehicleData.m_flags |= Vehicle.Flags.WaitingSpace;
                return false;
            }
            vehicleData.Spawn(vehicleID);
            vehicleData.m_flags &= ~Vehicle.Flags.WaitingSpace;
        }
        return true;
    }

    protected override void UpdateNodeTargetPos(ushort vehicleID, ref Vehicle vehicleData, ushort nodeID, ref NetNode nodeData, ref Vector4 targetPos, int index)
    {
        if ((nodeData.m_flags & NetNode.Flags.LevelCrossing) != NetNode.Flags.None)
        {
            if (targetPos.w > 4f)
            {
                targetPos.w = 4f;
            }
            if (index <= 0)
            {
                NetManager instance = Singleton<NetManager>.instance;
                for (int i = 0; i < 7; i++)
                {
                    ushort segment = nodeData.GetSegment(i);
                    if (segment != 0)
                    {
                        Vector3 vector;
                        Vector3 vector2;
                        float num3;
                        NetInfo segmentInfo = instance.m_segments.m_buffer[segment].Info;
                        if ((segmentInfo.m_class.m_service == ItemClass.Service.PublicTransport) && CalculateCrossing(segmentInfo, segment, ref instance.m_segments.m_buffer[segment], nodeID, out vector, out vector2, out num3))
                        {
                            for (int j = i + 1; j < 8; j++)
                            {
                                ushort num5 = nodeData.GetSegment(j);
                                if (num5 != 0)
                                {
                                    Vector3 vector3;
                                    Vector3 vector4;
                                    float num6;
                                    NetInfo info = instance.m_segments.m_buffer[num5].Info;
                                    if ((info.m_class.m_service == ItemClass.Service.PublicTransport) && CalculateCrossing(info, num5, ref instance.m_segments.m_buffer[num5], nodeID, out vector3, out vector4, out num6))
                                    {
                                        Vector3 vector5;
                                        Vector3 vector6;
                                        float num7;
                                        NetSegment.CalculateMiddlePoints(vector, vector2, vector3, vector4, true, true, out vector5, out vector6);
                                        float num8 = Mathf.Sqrt(Bezier2.XZ(vector, vector5, vector6, vector3).DistanceSqr(VectorUtils.XZ(targetPos), out num7));
                                        float num9 = num3 + ((num6 - num3) * num7);
                                        if (num8 < (num9 + 1f))
                                        {
                                            float num10 = (vector.y + ((vector3.y - vector.y) * num7)) + 0.1f;
                                            if (num8 > (num9 - 1f))
                                            {
                                                num10 -= ((num8 - num9) + 1f) * 0.3f;
                                            }
                                            if (num10 > targetPos.y)
                                            {
                                                targetPos.y = num10;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
