// Generated by .NET Reflector from C:\Projects\Skylines\DifficultyMod\DifficultyMod\libs\Assembly-CSharp.dll
using ColossalFramework;
using ColossalFramework.Globalization;
using ColossalFramework.Math;
using System;
using System.Runtime.InteropServices;
using UnityEngine;

public class CargoTruckAIMod : CarAIMod
{
    public int m_cargoCapacity = 1;
    public bool m_isHeavyVehicle;

    public override bool ArriveAtDestination(ushort vehicleID, ref Vehicle vehicleData)
    {
        if ((vehicleData.m_flags & Vehicle.Flags.WaitingTarget) != Vehicle.Flags.None)
        {
            return false;
        }
        if ((vehicleData.m_flags & Vehicle.Flags.GoingBack) != Vehicle.Flags.None)
        {
            return this.ArriveAtSource(vehicleID, ref vehicleData);
        }
        return this.ArriveAtTarget(vehicleID, ref vehicleData);
    }

    private bool ArriveAtSource(ushort vehicleID, ref Vehicle data)
    {
        if (data.m_sourceBuilding == 0)
        {
            Singleton<VehicleManager>.instance.ReleaseVehicle(vehicleID);
            return true;
        }
        int amountDelta = 0;
        if ((data.m_flags & Vehicle.Flags.TransferToSource) != Vehicle.Flags.None)
        {
            amountDelta = data.m_transferSize;
            Singleton<BuildingManager>.instance.m_buildings.m_buffer[data.m_sourceBuilding].Info.m_buildingAI.ModifyMaterialBuffer(data.m_sourceBuilding, ref Singleton<BuildingManager>.instance.m_buildings.m_buffer[data.m_sourceBuilding], (TransferManager.TransferReason)data.m_transferType, ref amountDelta);
            data.m_transferSize = (ushort)Mathf.Clamp(data.m_transferSize - amountDelta, 0, data.m_transferSize);
        }
        this.RemoveSource(vehicleID, ref data);
        Singleton<VehicleManager>.instance.ReleaseVehicle(vehicleID);
        return true;
    }

    private bool ArriveAtTarget(ushort vehicleID, ref Vehicle data)
    {
        if (data.m_targetBuilding == 0)
        {
            return true;
        }
        int amountDelta = 0;
        if ((data.m_flags & Vehicle.Flags.TransferToTarget) != Vehicle.Flags.None)
        {
            amountDelta = data.m_transferSize;
        }
        if ((data.m_flags & Vehicle.Flags.TransferToSource) != Vehicle.Flags.None)
        {
            amountDelta = Mathf.Min(0, data.m_transferSize - this.m_cargoCapacity);
        }
        BuildingManager instance = Singleton<BuildingManager>.instance;
        BuildingInfo info = instance.m_buildings.m_buffer[data.m_targetBuilding].Info;
        info.m_buildingAI.ModifyMaterialBuffer(data.m_targetBuilding, ref instance.m_buildings.m_buffer[data.m_targetBuilding], (TransferManager.TransferReason)data.m_transferType, ref amountDelta);
        if ((data.m_flags & Vehicle.Flags.TransferToTarget) != Vehicle.Flags.None)
        {
            data.m_transferSize = (ushort)Mathf.Clamp(data.m_transferSize - amountDelta, 0, data.m_transferSize);
        }
        if ((data.m_flags & Vehicle.Flags.TransferToSource) != Vehicle.Flags.None)
        {
            data.m_transferSize = (ushort)(data.m_transferSize + ((ushort)Mathf.Max(0, -amountDelta)));
        }
        if ((data.m_sourceBuilding != 0) && ((instance.m_buildings.m_buffer[data.m_sourceBuilding].m_flags & Building.Flags.IncomingOutgoing) == Building.Flags.Outgoing))
        {
            BuildingInfo info2 = instance.m_buildings.m_buffer[data.m_sourceBuilding].Info;
            ushort num2 = instance.FindBuilding(instance.m_buildings.m_buffer[data.m_sourceBuilding].m_position, 200f, info2.m_class.m_service, info2.m_class.m_subService, Building.Flags.Incoming, Building.Flags.Outgoing);
            if (num2 != 0)
            {
                instance.m_buildings.m_buffer[data.m_sourceBuilding].RemoveOwnVehicle(vehicleID, ref data);
                data.m_sourceBuilding = num2;
                instance.m_buildings.m_buffer[data.m_sourceBuilding].AddOwnVehicle(vehicleID, ref data);
            }
        }
        if ((instance.m_buildings.m_buffer[data.m_targetBuilding].m_flags & Building.Flags.IncomingOutgoing) == Building.Flags.Incoming)
        {
            ushort index = instance.FindBuilding(instance.m_buildings.m_buffer[data.m_targetBuilding].m_position, 200f, info.m_class.m_service, info.m_class.m_subService, Building.Flags.Outgoing, Building.Flags.Incoming);
            if (index != 0)
            {
                Vector3 vector;
                Vector3 vector2;
                data.Unspawn(vehicleID);
                BuildingInfo info3 = instance.m_buildings.m_buffer[index].Info;
                Randomizer randomizer = new Randomizer((int)vehicleID);
                info3.m_buildingAI.CalculateSpawnPosition(index, ref instance.m_buildings.m_buffer[index], ref randomizer, base.m_info, out vector, out vector2);
                Quaternion identity = Quaternion.identity;
                Vector3 forward = vector2 - vector;
                if (forward.sqrMagnitude > 0.01f)
                {
                    identity = Quaternion.LookRotation(forward);
                }
                data.m_frame0 = new Vehicle.Frame(vector, identity);
                data.m_frame1 = data.m_frame0;
                data.m_frame2 = data.m_frame0;
                data.m_frame3 = data.m_frame0;
                data.m_targetPos0 = vector;
                data.m_targetPos0.w = 2f;
                data.m_targetPos1 = vector2;
                data.m_targetPos1.w = 2f;
                data.m_targetPos2 = data.m_targetPos1;
                data.m_targetPos3 = data.m_targetPos1;
                this.FrameDataUpdated(vehicleID, ref data, ref data.m_frame0);
                this.SetTarget(vehicleID, ref data, 0);
                return true;
            }
        }
        this.SetTarget(vehicleID, ref data, 0);
        return false;
    }

    public override void BuildingRelocated(ushort vehicleID, ref Vehicle data, ushort building)
    {
        base.BuildingRelocated(vehicleID, ref data, building);
        if (building == data.m_sourceBuilding)
        {
            if ((data.m_flags & Vehicle.Flags.GoingBack) != Vehicle.Flags.None)
            {
                this.InvalidPath(vehicleID, ref data, vehicleID, ref data);
            }
        }
        else if ((building == data.m_targetBuilding) && ((data.m_flags & Vehicle.Flags.GoingBack) == Vehicle.Flags.None))
        {
            this.InvalidPath(vehicleID, ref data, vehicleID, ref data);
        }
    }

    protected override bool ChangeVehicleType(ushort vehicleID, ref Vehicle vehicleData, PathUnit.Position pathPos, uint laneID)
    {
        ushort num3;
        if ((vehicleData.m_flags & (Vehicle.Flags.GoingBack | Vehicle.Flags.TransferToSource)) != Vehicle.Flags.None)
        {
            return false;
        }
        VehicleManager instance = Singleton<VehicleManager>.instance;
        NetManager manager2 = Singleton<NetManager>.instance;
        BuildingManager manager3 = Singleton<BuildingManager>.instance;
        NetInfo info = manager2.m_segments.m_buffer[pathPos.m_segment].Info;
        Vector3 pos = manager2.m_lanes.m_buffer[laneID].CalculatePosition(vehicleData.m_lastPathOffset * 0.003921569f);
        Vector3 lastPos = pos;
        if (!SkipNonCarPaths(ref vehicleData.m_path, ref vehicleData.m_pathPositionIndex, ref vehicleData.m_lastPathOffset, ref lastPos))
        {
            return false;
        }
        ushort index = manager3.FindBuilding(pos, 100f, info.m_class.m_service, info.m_class.m_subService, Building.Flags.None, Building.Flags.None);
        ushort num2 = manager3.FindBuilding(lastPos, 100f, info.m_class.m_service, info.m_class.m_subService, Building.Flags.None, Building.Flags.None);
        bool flag = false;
        if ((index != 0) && ((manager3.m_buildings.m_buffer[index].m_flags & Building.Flags.Active) != Building.Flags.None))
        {
            flag = true;
        }
        bool flag2 = false;
        if ((num2 != 0) && ((manager3.m_buildings.m_buffer[num2].m_flags & Building.Flags.Active) != Building.Flags.None))
        {
            flag2 = true;
        }
        if ((flag && flag2) && instance.CreateVehicle(out num3, ref Singleton<SimulationManager>.instance.m_randomizer, base.m_info, pos, (TransferManager.TransferReason)vehicleData.m_transferType, false, true))
        {
            VehicleInfo info2;
            if (vehicleData.m_targetBuilding != 0)
            {
                instance.m_vehicles.m_buffer[num3].m_targetBuilding = vehicleData.m_targetBuilding;
                instance.m_vehicles.m_buffer[num3].m_flags &= ~Vehicle.Flags.WaitingTarget;
                manager3.m_buildings.m_buffer[vehicleData.m_targetBuilding].AddGuestVehicle(num3, ref instance.m_vehicles.m_buffer[num3]);
            }
            instance.m_vehicles.m_buffer[num3].m_transferSize = vehicleData.m_transferSize;
            instance.m_vehicles.m_buffer[num3].m_path = vehicleData.m_path;
            instance.m_vehicles.m_buffer[num3].m_pathPositionIndex = vehicleData.m_pathPositionIndex;
            instance.m_vehicles.m_buffer[num3].m_lastPathOffset = vehicleData.m_lastPathOffset;
            instance.m_vehicles.m_buffer[num3].m_flags |= vehicleData.m_flags & (Vehicle.Flags.Exporting | Vehicle.Flags.Importing);
            vehicleData.m_path = 0;
            ushort num4 = FindCargoParent(index, num2, info.m_class.m_service, info.m_class.m_subService);
            if (num4 != 0)
            {
                info2 = instance.m_vehicles.m_buffer[num4].Info;
            }
            else
            {
                info2 = instance.GetRandomVehicleInfo(ref Singleton<SimulationManager>.instance.m_randomizer, info.m_class.m_service, info.m_class.m_subService, ItemClass.Level.Level4);
                if ((info2 != null) && instance.CreateVehicle(out num4, ref Singleton<SimulationManager>.instance.m_randomizer, info2, pos, TransferManager.TransferReason.None, false, true))
                {
                    info2.m_vehicleAI.SetSource(num4, ref instance.m_vehicles.m_buffer[num4], index);
                    info2.m_vehicleAI.SetTarget(num4, ref instance.m_vehicles.m_buffer[num4], num2);
                }
            }
            if (num4 != 0)
            {
                int num5;
                int num6;
                info2.m_vehicleAI.GetSize(num4, ref instance.m_vehicles.m_buffer[num4], out num5, out num6);
                instance.m_vehicles.m_buffer[num3].m_cargoParent = num4;
                instance.m_vehicles.m_buffer[num3].m_nextCargo = instance.m_vehicles.m_buffer[num4].m_firstCargo;
                instance.m_vehicles.m_buffer[num4].m_firstCargo = num3;
                instance.m_vehicles.m_buffer[num4].m_transferSize = (ushort)(++num5);
                if (num5 >= num6)
                {
                    instance.m_vehicles.m_buffer[num4].m_flags &= ~Vehicle.Flags.WaitingCargo;
                    instance.m_vehicles.m_buffer[num4].m_waitCounter = 0;
                    info2.m_vehicleAI.SetTarget(num4, ref instance.m_vehicles.m_buffer[num4], num2);
                }
            }
            else
            {
                instance.ReleaseVehicle(num3);
            }
        }
        vehicleData.m_transferSize = 0;
        if (index != 0)
        {
            Vector3 vector3;
            Vector3 vector4;
            vehicleData.Unspawn(vehicleID);
            BuildingInfo info3 = manager3.m_buildings.m_buffer[index].Info;
            Randomizer randomizer = new Randomizer((int)vehicleID);
            info3.m_buildingAI.CalculateSpawnPosition(index, ref manager3.m_buildings.m_buffer[index], ref randomizer, base.m_info, out vector3, out vector4);
            Quaternion identity = Quaternion.identity;
            Vector3 forward = vector4 - vector3;
            if (forward.sqrMagnitude > 0.01f)
            {
                identity = Quaternion.LookRotation(forward);
            }
            vehicleData.m_frame0 = new Vehicle.Frame(vector3, identity);
            vehicleData.m_frame1 = vehicleData.m_frame0;
            vehicleData.m_frame2 = vehicleData.m_frame0;
            vehicleData.m_frame3 = vehicleData.m_frame0;
            vehicleData.m_targetPos0 = vector3;
            vehicleData.m_targetPos0.w = 2f;
            vehicleData.m_targetPos1 = vector4;
            vehicleData.m_targetPos1.w = 2f;
            vehicleData.m_targetPos2 = vehicleData.m_targetPos1;
            vehicleData.m_targetPos3 = vehicleData.m_targetPos1;
            if (index == vehicleData.m_sourceBuilding)
            {
                this.RemoveTarget(vehicleID, ref vehicleData);
                vehicleData.m_flags &= ~Vehicle.Flags.WaitingTarget;
                vehicleData.m_flags |= Vehicle.Flags.GoingBack;
                vehicleData.m_waitCounter = 0;
                return true;
            }
        }
        else
        {
            vehicleData.m_targetPos1 = vehicleData.m_targetPos0;
            vehicleData.m_targetPos2 = vehicleData.m_targetPos0;
            vehicleData.m_targetPos3 = vehicleData.m_targetPos0;
        }
        this.SetTarget(vehicleID, ref vehicleData, 0);
        return true;
    }

    public override void CreateVehicle(ushort vehicleID, ref Vehicle data)
    {
        base.CreateVehicle(vehicleID, ref data);
        data.m_flags |= Vehicle.Flags.WaitingTarget;
    }

    private static ushort FindCargoParent(ushort sourceBuilding, ushort targetBuilding, ItemClass.Service service, ItemClass.SubService subService)
    {
        BuildingManager instance = Singleton<BuildingManager>.instance;
        VehicleManager manager2 = Singleton<VehicleManager>.instance;
        ushort ownVehicles = instance.m_buildings.m_buffer[sourceBuilding].m_ownVehicles;
        int num2 = 0;
        while (ownVehicles != 0)
        {
            if ((manager2.m_vehicles.m_buffer[ownVehicles].m_targetBuilding == targetBuilding) && ((manager2.m_vehicles.m_buffer[ownVehicles].m_flags & Vehicle.Flags.WaitingCargo) != Vehicle.Flags.None))
            {
                VehicleInfo info = manager2.m_vehicles.m_buffer[ownVehicles].Info;
                if ((info.m_class.m_service == service) && (info.m_class.m_subService == subService))
                {
                    return ownVehicles;
                }
            }
            ownVehicles = manager2.m_vehicles.m_buffer[ownVehicles].m_nextOwnVehicle;
            if (++num2 >= 0x4000)
            {
                CODebugBase<LogChannel>.Error(LogChannel.Core, "Invalid list detected!\n" + System.Environment.StackTrace);
                break;
            }
        }
        return 0;
    }

    public static ushort FindNextCargoParent(ushort sourceBuilding, ItemClass.Service service, ItemClass.SubService subService)
    {
        BuildingManager instance = Singleton<BuildingManager>.instance;
        VehicleManager manager2 = Singleton<VehicleManager>.instance;
        ushort ownVehicles = instance.m_buildings.m_buffer[sourceBuilding].m_ownVehicles;
        ushort num2 = 0;
        int num3 = -1;
        int num4 = 0;
        while (ownVehicles != 0)
        {
            if ((manager2.m_vehicles.m_buffer[ownVehicles].m_flags & Vehicle.Flags.WaitingCargo) != Vehicle.Flags.None)
            {
                VehicleInfo info = manager2.m_vehicles.m_buffer[ownVehicles].Info;
                if ((info.m_class.m_service == service) && (info.m_class.m_subService == subService))
                {
                    int num5;
                    int num6;
                    info.m_vehicleAI.GetSize(ownVehicles, ref manager2.m_vehicles.m_buffer[ownVehicles], out num5, out num6);
                    int num7 = Mathf.Max((num5 * 0xff) / Mathf.Max(1, num6), (int)manager2.m_vehicles.m_buffer[ownVehicles].m_waitCounter);
                    if (num7 > num3)
                    {
                        num2 = ownVehicles;
                        num3 = num7;
                    }
                }
            }
            ownVehicles = manager2.m_vehicles.m_buffer[ownVehicles].m_nextOwnVehicle;
            if (++num4 >= 0x4000)
            {
                CODebugBase<LogChannel>.Error(LogChannel.Core, "Invalid list detected!\n" + System.Environment.StackTrace);
                return num2;
            }
        }
        return num2;
    }

    public override void GetBufferStatus(ushort vehicleID, ref Vehicle data, out string localeKey, out int current, out int max)
    {
        localeKey = "Default";
        current = data.m_transferSize;
        max = this.m_cargoCapacity;
    }

    public override Color GetColor(ushort vehicleID, ref Vehicle data, InfoManager.InfoMode infoMode)
    {
        if (infoMode != InfoManager.InfoMode.Connections)
        {
            return base.GetColor(vehicleID, ref data, infoMode);
        }
        InfoManager.SubInfoMode currentSubMode = Singleton<InfoManager>.instance.CurrentSubMode;
        TransferManager.TransferReason transferType = (TransferManager.TransferReason)data.m_transferType;
        if (((currentSubMode == InfoManager.SubInfoMode.Default) && ((data.m_flags & Vehicle.Flags.Importing) != Vehicle.Flags.None)) && (transferType != TransferManager.TransferReason.None))
        {
            return Singleton<TransferManager>.instance.m_properties.m_resourceColors[(int)transferType];
        }
        if (((currentSubMode == InfoManager.SubInfoMode.WaterPower) && ((data.m_flags & Vehicle.Flags.Exporting) != Vehicle.Flags.None)) && (transferType != TransferManager.TransferReason.None))
        {
            return Singleton<TransferManager>.instance.m_properties.m_resourceColors[(int)transferType];
        }
        return Singleton<InfoManager>.instance.m_properties.m_neutralColor;
    }

    public override string GetLocalizedStatus(ushort vehicleID, ref Vehicle data, out InstanceID target)
    {
        if ((data.m_flags & Vehicle.Flags.TransferToTarget) != Vehicle.Flags.None)
        {
            ushort targetBuilding = data.m_targetBuilding;
            if ((data.m_flags & Vehicle.Flags.GoingBack) != Vehicle.Flags.None)
            {
                target = InstanceID.Empty;
                return Locale.Get("VEHICLE_STATUS_CARGOTRUCK_RETURN");
            }
            if ((data.m_flags & Vehicle.Flags.WaitingTarget) != Vehicle.Flags.None)
            {
                target = InstanceID.Empty;
                return Locale.Get("VEHICLE_STATUS_CARGOTRUCK_UNLOAD");
            }
            if (targetBuilding != 0)
            {
                Building.Flags flags = Singleton<BuildingManager>.instance.m_buildings.m_buffer[targetBuilding].m_flags;
                TransferManager.TransferReason transferType = (TransferManager.TransferReason)data.m_transferType;
                if (((data.m_flags & Vehicle.Flags.Exporting) != Vehicle.Flags.None) || ((flags & Building.Flags.IncomingOutgoing) != Building.Flags.None))
                {
                    target = InstanceID.Empty;
                    return Locale.Get("VEHICLE_STATUS_CARGOTRUCK_EXPORT", transferType.ToString());
                }
                if ((data.m_flags & Vehicle.Flags.Importing) != Vehicle.Flags.None)
                {
                    target = InstanceID.Empty;
                    target.Building = targetBuilding;
                    return Locale.Get("VEHICLE_STATUS_CARGOTRUCK_IMPORT", transferType.ToString());
                }
                target = InstanceID.Empty;
                target.Building = targetBuilding;
                return Locale.Get("VEHICLE_STATUS_CARGOTRUCK_DELIVER", transferType.ToString());
            }
        }
        target = InstanceID.Empty;
        return Locale.Get("VEHICLE_STATUS_CONFUSED");
    }

    public override void GetSize(ushort vehicleID, ref Vehicle data, out int size, out int max)
    {
        size = data.m_transferSize;
        max = this.m_cargoCapacity;
    }

    public override InstanceID GetTargetID(ushort vehicleID, ref Vehicle vehicleData)
    {
        InstanceID eid = new InstanceID();
        if ((vehicleData.m_flags & Vehicle.Flags.GoingBack) != Vehicle.Flags.None)
        {
            eid.Building = vehicleData.m_sourceBuilding;
            return eid;
        }
        eid.Building = vehicleData.m_targetBuilding;
        return eid;
    }

    protected override bool IsHeavyVehicle()
    {
        return this.m_isHeavyVehicle;
    }

    public override void LoadVehicle(ushort vehicleID, ref Vehicle data)
    {
        base.LoadVehicle(vehicleID, ref data);
        if (data.m_sourceBuilding != 0)
        {
            Singleton<BuildingManager>.instance.m_buildings.m_buffer[data.m_sourceBuilding].AddOwnVehicle(vehicleID, ref data);
        }
        if (data.m_targetBuilding != 0)
        {
            Singleton<BuildingManager>.instance.m_buildings.m_buffer[data.m_targetBuilding].AddGuestVehicle(vehicleID, ref data);
        }
    }

    protected override bool NeedChangeVehicleType(ushort vehicleID, ref Vehicle vehicleData, PathUnit.Position pathPos, uint laneID, VehicleInfo.VehicleType laneVehicleType, ref Vector4 targetPos)
    {
        byte num;
        if ((laneVehicleType != VehicleInfo.VehicleType.Train) && (laneVehicleType != VehicleInfo.VehicleType.Ship))
        {
            return false;
        }
        NetManager instance = Singleton<NetManager>.instance;
        BuildingManager manager2 = Singleton<BuildingManager>.instance;
        NetInfo info = instance.m_segments.m_buffer[pathPos.m_segment].Info;
        PathUnit.CalculatePathPositionOffset(laneID, (Vector3)targetPos, out num);
        Vector3 pos = instance.m_lanes.m_buffer[laneID].CalculatePosition(num * 0.003921569f);
        ushort index = manager2.FindBuilding(pos, 100f, info.m_class.m_service, info.m_class.m_subService, Building.Flags.None, Building.Flags.None);
        if (index != 0)
        {
            Vector3 vector2;
            Vector3 vector3;
            BuildingInfo info2 = manager2.m_buildings.m_buffer[index].Info;
            Randomizer randomizer = new Randomizer((int)vehicleID);
            info2.m_buildingAI.CalculateUnspawnPosition(vehicleData.m_targetBuilding, ref manager2.m_buildings.m_buffer[index], ref randomizer, base.m_info, out vector2, out vector3);
            targetPos = vector2;
            targetPos.w = 4f;
        }
        return true;
    }

    protected override void PathfindFailure(ushort vehicleID, ref Vehicle data)
    {
        BuildingManager instance = Singleton<BuildingManager>.instance;
        if (data.m_sourceBuilding != 0)
        {
            BuildingAI.PathFindType type = ((data.m_flags & Vehicle.Flags.DummyTraffic) == Vehicle.Flags.None) ? BuildingAI.PathFindType.LeavingCargo : BuildingAI.PathFindType.LeavingDummy;
            instance.m_buildings.m_buffer[data.m_sourceBuilding].Info.m_buildingAI.PathfindFailure(data.m_sourceBuilding, ref instance.m_buildings.m_buffer[data.m_sourceBuilding], type);
        }
        if (data.m_targetBuilding != 0)
        {
            BuildingAI.PathFindType type2 = ((data.m_flags & Vehicle.Flags.DummyTraffic) == Vehicle.Flags.None) ? BuildingAI.PathFindType.EnteringCargo : BuildingAI.PathFindType.EnteringDummy;
            instance.m_buildings.m_buffer[data.m_targetBuilding].Info.m_buildingAI.PathfindFailure(data.m_targetBuilding, ref instance.m_buildings.m_buffer[data.m_targetBuilding], type2);
        }
        base.PathfindFailure(vehicleID, ref data);
    }

    protected override void PathfindSuccess(ushort vehicleID, ref Vehicle data)
    {
        BuildingManager instance = Singleton<BuildingManager>.instance;
        if (data.m_sourceBuilding != 0)
        {
            BuildingAI.PathFindType type = ((data.m_flags & Vehicle.Flags.DummyTraffic) == Vehicle.Flags.None) ? BuildingAI.PathFindType.LeavingCargo : BuildingAI.PathFindType.LeavingDummy;
            instance.m_buildings.m_buffer[data.m_sourceBuilding].Info.m_buildingAI.PathfindSuccess(data.m_sourceBuilding, ref instance.m_buildings.m_buffer[data.m_sourceBuilding], type);
        }
        if (data.m_targetBuilding != 0)
        {
            BuildingAI.PathFindType type2 = ((data.m_flags & Vehicle.Flags.DummyTraffic) == Vehicle.Flags.None) ? BuildingAI.PathFindType.EnteringCargo : BuildingAI.PathFindType.EnteringDummy;
            instance.m_buildings.m_buffer[data.m_targetBuilding].Info.m_buildingAI.PathfindSuccess(data.m_targetBuilding, ref instance.m_buildings.m_buffer[data.m_targetBuilding], type2);
        }
        base.PathfindSuccess(vehicleID, ref data);
    }

    public override void ReleaseVehicle(ushort vehicleID, ref Vehicle data)
    {
        this.RemoveOffers(vehicleID, ref data);
        this.RemoveSource(vehicleID, ref data);
        this.RemoveTarget(vehicleID, ref data);
        base.ReleaseVehicle(vehicleID, ref data);
    }

    private void RemoveOffers(ushort vehicleID, ref Vehicle data)
    {
        if ((data.m_flags & Vehicle.Flags.WaitingTarget) != Vehicle.Flags.None)
        {
            TransferManager.TransferOffer offer = new TransferManager.TransferOffer
            {
                Vehicle = vehicleID
            };
            if ((data.m_flags & Vehicle.Flags.TransferToSource) != Vehicle.Flags.None)
            {
                Singleton<TransferManager>.instance.RemoveIncomingOffer((TransferManager.TransferReason)data.m_transferType, offer);
            }
            else if ((data.m_flags & Vehicle.Flags.TransferToTarget) != Vehicle.Flags.None)
            {
                Singleton<TransferManager>.instance.RemoveOutgoingOffer((TransferManager.TransferReason)data.m_transferType, offer);
            }
        }
    }

    private void RemoveSource(ushort vehicleID, ref Vehicle data)
    {
        if (data.m_sourceBuilding != 0)
        {
            Singleton<BuildingManager>.instance.m_buildings.m_buffer[data.m_sourceBuilding].RemoveOwnVehicle(vehicleID, ref data);
            data.m_sourceBuilding = 0;
        }
    }

    private void RemoveTarget(ushort vehicleID, ref Vehicle data)
    {
        if (data.m_targetBuilding != 0)
        {
            Singleton<BuildingManager>.instance.m_buildings.m_buffer[data.m_targetBuilding].RemoveGuestVehicle(vehicleID, ref data);
            data.m_targetBuilding = 0;
        }
    }

    public override void SetSource(ushort vehicleID, ref Vehicle data, ushort sourceBuilding)
    {
        this.RemoveSource(vehicleID, ref data);
        data.m_sourceBuilding = sourceBuilding;
        if (sourceBuilding != 0)
        {
            Vector3 vector;
            Vector3 vector2;
            BuildingManager instance = Singleton<BuildingManager>.instance;
            BuildingInfo info = instance.m_buildings.m_buffer[sourceBuilding].Info;
            data.Unspawn(vehicleID);
            Randomizer randomizer = new Randomizer((int)vehicleID);
            info.m_buildingAI.CalculateSpawnPosition(sourceBuilding, ref instance.m_buildings.m_buffer[sourceBuilding], ref randomizer, base.m_info, out vector, out vector2);
            Quaternion identity = Quaternion.identity;
            Vector3 forward = vector2 - vector;
            if (forward.sqrMagnitude > 0.01f)
            {
                identity = Quaternion.LookRotation(forward);
            }
            data.m_frame0 = new Vehicle.Frame(vector, identity);
            data.m_frame1 = data.m_frame0;
            data.m_frame2 = data.m_frame0;
            data.m_frame3 = data.m_frame0;
            data.m_targetPos0 = vector;
            data.m_targetPos0.w = 2f;
            data.m_targetPos1 = vector2;
            data.m_targetPos1.w = 2f;
            data.m_targetPos2 = data.m_targetPos1;
            data.m_targetPos3 = data.m_targetPos1;
            if ((data.m_flags & Vehicle.Flags.TransferToTarget) != Vehicle.Flags.None)
            {
                int amountDelta = Mathf.Min(0, data.m_transferSize - this.m_cargoCapacity);
                info.m_buildingAI.ModifyMaterialBuffer(sourceBuilding, ref instance.m_buildings.m_buffer[sourceBuilding], (TransferManager.TransferReason)data.m_transferType, ref amountDelta);
                amountDelta = Mathf.Max(0, -amountDelta);
                data.m_transferSize = (ushort)(data.m_transferSize + ((ushort)amountDelta));
            }
            this.FrameDataUpdated(vehicleID, ref data, ref data.m_frame0);
            instance.m_buildings.m_buffer[sourceBuilding].AddOwnVehicle(vehicleID, ref data);
            if ((instance.m_buildings.m_buffer[sourceBuilding].m_flags & Building.Flags.IncomingOutgoing) != Building.Flags.None)
            {
                if ((data.m_flags & Vehicle.Flags.TransferToTarget) != Vehicle.Flags.None)
                {
                    data.m_flags |= Vehicle.Flags.Importing;
                }
                else if ((data.m_flags & Vehicle.Flags.TransferToSource) != Vehicle.Flags.None)
                {
                    data.m_flags |= Vehicle.Flags.Exporting;
                }
            }
        }
    }

    public override void SetTarget(ushort vehicleID, ref Vehicle data, ushort targetBuilding)
    {
        if (targetBuilding == data.m_targetBuilding)
        {
            if (data.m_path == 0)
            {
                if (!this.StartPathFind(vehicleID, ref data))
                {
                    data.Unspawn(vehicleID);
                }
            }
            else
            {
                this.TrySpawn(vehicleID, ref data);
            }
        }
        else
        {
            this.RemoveTarget(vehicleID, ref data);
            data.m_targetBuilding = targetBuilding;
            data.m_flags &= ~Vehicle.Flags.WaitingTarget;
            data.m_waitCounter = 0;
            if (targetBuilding != 0)
            {
                Singleton<BuildingManager>.instance.m_buildings.m_buffer[targetBuilding].AddGuestVehicle(vehicleID, ref data);
                if ((Singleton<BuildingManager>.instance.m_buildings.m_buffer[targetBuilding].m_flags & Building.Flags.IncomingOutgoing) != Building.Flags.None)
                {
                    if ((data.m_flags & Vehicle.Flags.TransferToTarget) != Vehicle.Flags.None)
                    {
                        data.m_flags |= Vehicle.Flags.Exporting;
                    }
                    else if ((data.m_flags & Vehicle.Flags.TransferToSource) != Vehicle.Flags.None)
                    {
                        data.m_flags |= Vehicle.Flags.Importing;
                    }
                }
            }
            else
            {
                if ((data.m_flags & Vehicle.Flags.TransferToTarget) != Vehicle.Flags.None)
                {
                    if (data.m_transferSize > 0)
                    {
                        TransferManager.TransferOffer offer = new TransferManager.TransferOffer
                        {
                            Priority = 7,
                            Vehicle = vehicleID
                        };
                        if (data.m_sourceBuilding != 0)
                        {
                            offer.Position = (Vector3)((data.GetLastFramePosition() + Singleton<BuildingManager>.instance.m_buildings.m_buffer[data.m_sourceBuilding].m_position) * 0.5f);
                        }
                        else
                        {
                            offer.Position = data.GetLastFramePosition();
                        }
                        offer.Amount = 1;
                        offer.Active = true;
                        Singleton<TransferManager>.instance.AddOutgoingOffer((TransferManager.TransferReason)data.m_transferType, offer);
                        data.m_flags |= Vehicle.Flags.WaitingTarget;
                    }
                    else
                    {
                        data.m_flags |= Vehicle.Flags.GoingBack;
                    }
                }
                if ((data.m_flags & Vehicle.Flags.TransferToSource) != Vehicle.Flags.None)
                {
                    if (data.m_transferSize < this.m_cargoCapacity)
                    {
                        TransferManager.TransferOffer offer2 = new TransferManager.TransferOffer
                        {
                            Priority = 7,
                            Vehicle = vehicleID
                        };
                        if (data.m_sourceBuilding != 0)
                        {
                            offer2.Position = (Vector3)((data.GetLastFramePosition() + Singleton<BuildingManager>.instance.m_buildings.m_buffer[data.m_sourceBuilding].m_position) * 0.5f);
                        }
                        else
                        {
                            offer2.Position = data.GetLastFramePosition();
                        }
                        offer2.Amount = 1;
                        offer2.Active = true;
                        Singleton<TransferManager>.instance.AddIncomingOffer((TransferManager.TransferReason)data.m_transferType, offer2);
                        data.m_flags |= Vehicle.Flags.WaitingTarget;
                    }
                    else
                    {
                        data.m_flags |= Vehicle.Flags.GoingBack;
                    }
                }
            }
            if (data.m_cargoParent != 0)
            {
                if (data.m_path != 0)
                {
                    if (data.m_path != 0)
                    {
                        Singleton<PathManager>.instance.ReleasePath(data.m_path);
                    }
                    data.m_path = 0;
                }
            }
            else if (!this.StartPathFind(vehicleID, ref data))
            {
                data.Unspawn(vehicleID);
            }
        }
    }

    public override void SimulationStep(ushort vehicleID, ref Vehicle data, Vector3 physicsLodRefPos)
    {
        if ((data.m_flags & Vehicle.Flags.Congestion) != Vehicle.Flags.None)
        {
            Singleton<VehicleManager>.instance.ReleaseVehicle(vehicleID);
        }
        else
        {
            if (((data.m_flags & Vehicle.Flags.WaitingTarget) != Vehicle.Flags.None) && ((data.m_waitCounter = (byte)(data.m_waitCounter + 1)) > 20))
            {
                this.RemoveOffers(vehicleID, ref data);
                data.m_flags &= ~Vehicle.Flags.WaitingTarget;
                data.m_flags |= Vehicle.Flags.GoingBack;
                data.m_waitCounter = 0;
                if (!this.StartPathFind(vehicleID, ref data))
                {
                    data.Unspawn(vehicleID);
                }
            }
            base.SimulationStep(vehicleID, ref data, physicsLodRefPos);
        }
    }

    private static bool SkipNonCarPaths(ref uint path, ref byte pathPositionIndex, ref byte lastPathOffset, ref Vector3 lastPos)
    {
        PathManager instance = Singleton<PathManager>.instance;
        NetManager manager2 = Singleton<NetManager>.instance;
        int num = 0;
        PathUnit.Position pathPos = new PathUnit.Position();
        while (path != 0)
        {
            PathUnit.Position position2;
            if (!instance.m_pathUnits.m_buffer[path].GetPosition(pathPositionIndex >> 1, out position2))
            {
                return false;
            }
            NetInfo info = manager2.m_segments.m_buffer[position2.m_segment].Info;
            if (((info.m_lanes != null) && (info.m_lanes.Length > position2.m_lane)) && (info.m_lanes[position2.m_lane].m_vehicleType == VehicleInfo.VehicleType.Car))
            {
                if (pathPos.m_segment != 0)
                {
                    uint laneID = PathManager.GetLaneID(pathPos);
                    uint num3 = PathManager.GetLaneID(position2);
                    if ((laneID != 0) && (num3 != 0))
                    {
                        lastPos = manager2.m_lanes.m_buffer[laneID].CalculatePosition(pathPos.m_offset * 0.003921569f);
                        PathUnit.CalculatePathPositionOffset(num3, lastPos, out lastPathOffset);
                        return true;
                    }
                }
                return false;
            }
            pathPos = position2;
            int num4 = (pathPositionIndex >> 1) + 1;
            if (num4 >= instance.m_pathUnits.m_buffer[path].m_positionCount)
            {
                num4 = 0;
                Singleton<PathManager>.instance.ReleaseFirstUnit(ref path);
            }
            pathPositionIndex = (byte)(num4 << 1);
            if (++num >= 0x40000)
            {
                CODebugBase<LogChannel>.Error(LogChannel.Core, "Invalid list detected!\n" + System.Environment.StackTrace);
                break;
            }
        }
        if (pathPos.m_segment != 0)
        {
            uint index = PathManager.GetLaneID(pathPos);
            if (index != 0)
            {
                lastPos = manager2.m_lanes.m_buffer[index].CalculatePosition(pathPos.m_offset * 0.003921569f);
                return true;
            }
        }
        return false;
    }

    protected override bool StartPathFind(ushort vehicleID, ref Vehicle vehicleData)
    {
        if ((vehicleData.m_flags & Vehicle.Flags.WaitingTarget) != Vehicle.Flags.None)
        {
            return true;
        }
        if ((vehicleData.m_flags & Vehicle.Flags.GoingBack) != Vehicle.Flags.None)
        {
            if (vehicleData.m_sourceBuilding != 0)
            {
                Vector3 vector;
                Vector3 vector2;
                BuildingManager instance = Singleton<BuildingManager>.instance;
                BuildingInfo info = instance.m_buildings.m_buffer[vehicleData.m_sourceBuilding].Info;
                Randomizer randomizer = new Randomizer((int)vehicleID);
                info.m_buildingAI.CalculateUnspawnPosition(vehicleData.m_sourceBuilding, ref instance.m_buildings.m_buffer[vehicleData.m_sourceBuilding], ref randomizer, base.m_info, out vector, out vector2);
                return this.StartPathFind(vehicleID, ref vehicleData, (Vector3)vehicleData.m_targetPos3, vector2);
            }
        }
        else if (vehicleData.m_targetBuilding != 0)
        {
            Vector3 vector3;
            Vector3 vector4;
            BuildingManager manager2 = Singleton<BuildingManager>.instance;
            BuildingInfo info2 = manager2.m_buildings.m_buffer[vehicleData.m_targetBuilding].Info;
            Randomizer randomizer2 = new Randomizer((int)vehicleID);
            info2.m_buildingAI.CalculateUnspawnPosition(vehicleData.m_targetBuilding, ref manager2.m_buildings.m_buffer[vehicleData.m_targetBuilding], ref randomizer2, base.m_info, out vector3, out vector4);
            return this.StartPathFind(vehicleID, ref vehicleData, (Vector3)vehicleData.m_targetPos3, vector4);
        }
        return false;
    }

    protected override bool StartPathFind(ushort vehicleID, ref Vehicle vehicleData, Vector3 startPos, Vector3 endPos, bool startBothWays, bool endBothWays)
    {
        PathUnit.Position position;
        PathUnit.Position position2;
        PathUnit.Position position3;
        PathUnit.Position position4;
        float num;
        float num2;
        float num3;
        float num4;
        PathUnit.Position position5;
        PathUnit.Position position6;
        float num5;
        float num6;
        PathUnit.Position position7;
        PathUnit.Position position8;
        float num7;
        float num8;
        if ((vehicleData.m_flags & (Vehicle.Flags.GoingBack | Vehicle.Flags.TransferToSource)) != Vehicle.Flags.None)
        {
            return base.StartPathFind(vehicleID, ref vehicleData, startPos, endPos, startBothWays, endBothWays);
        }
        bool flag = PathManager.FindPathPosition(startPos, ItemClass.Service.Road, NetInfo.LaneType.None | NetInfo.LaneType.Vehicle, VehicleInfo.VehicleType.Car, 32f, out position, out position2, out num, out num2);
        if (PathManager.FindPathPosition(startPos, ItemClass.Service.PublicTransport, NetInfo.LaneType.None | NetInfo.LaneType.Vehicle, VehicleInfo.VehicleType.Ship | VehicleInfo.VehicleType.Train, 32f, out position5, out position6, out num5, out num6))
        {
            if (!flag || (num5 < num))
            {
                position = position5;
                position2 = position6;
                num = num5;
                num2 = num6;
            }
            flag = true;
        }
        bool flag2 = PathManager.FindPathPosition(endPos, ItemClass.Service.Road, NetInfo.LaneType.None | NetInfo.LaneType.Vehicle, VehicleInfo.VehicleType.Car, 32f, out position3, out position4, out num3, out num4);
        if (PathManager.FindPathPosition(endPos, ItemClass.Service.PublicTransport, NetInfo.LaneType.None | NetInfo.LaneType.Vehicle, VehicleInfo.VehicleType.Ship | VehicleInfo.VehicleType.Train, 32f, out position7, out position8, out num7, out num8))
        {
            if (!flag2 || (num7 < num3))
            {
                position3 = position7;
                position4 = position8;
                num3 = num7;
                num4 = num8;
            }
            flag2 = true;
        }
        if (flag && flag2)
        {
            uint num9;
            PathManager instance = Singleton<PathManager>.instance;
            if (!startBothWays || (num < 10f))
            {
                position2 = new PathUnit.Position();
            }
            if (!endBothWays || (num3 < 10f))
            {
                position4 = new PathUnit.Position();
            }
            NetInfo.LaneType laneTypes = NetInfo.LaneType.Cargo | NetInfo.LaneType.Vehicle;
            VehicleInfo.VehicleType vehicleTypes = VehicleInfo.VehicleType.Ship | VehicleInfo.VehicleType.Train | VehicleInfo.VehicleType.Car;
            if (instance.CreatePath(out num9, ref Singleton<SimulationManager>.instance.m_randomizer, Singleton<SimulationManager>.instance.m_currentBuildIndex, position, position2, position3, position4, laneTypes, vehicleTypes, 20000f, this.IsHeavyVehicle(), this.IgnoreBlocked(vehicleID, ref vehicleData), false, false))
            {
                if (vehicleData.m_path != 0)
                {
                    instance.ReleasePath(vehicleData.m_path);
                }
                vehicleData.m_path = num9;
                vehicleData.m_flags |= Vehicle.Flags.WaitingPath;
                return true;
            }
        }
        return false;
    }

    public override void StartTransfer(ushort vehicleID, ref Vehicle data, TransferManager.TransferReason material, TransferManager.TransferOffer offer)
    {
        if (material == ((TransferManager.TransferReason)data.m_transferType))
        {
            if ((data.m_flags & Vehicle.Flags.WaitingTarget) != Vehicle.Flags.None)
            {
                this.SetTarget(vehicleID, ref data, offer.Building);
            }
        }
        else
        {
            base.StartTransfer(vehicleID, ref data, material, offer);
        }
    }

    public static void SwitchCargoParent(ushort source, ushort target)
    {
        VehicleManager instance = Singleton<VehicleManager>.instance;
        ushort firstCargo = instance.m_vehicles.m_buffer[source].m_firstCargo;
        instance.m_vehicles.m_buffer[source].m_firstCargo = 0;
        instance.m_vehicles.m_buffer[target].m_firstCargo = firstCargo;
        instance.m_vehicles.m_buffer[target].m_transferSize = instance.m_vehicles.m_buffer[source].m_transferSize;
        int num2 = 0;
        while (firstCargo != 0)
        {
            instance.m_vehicles.m_buffer[firstCargo].m_cargoParent = target;
            firstCargo = instance.m_vehicles.m_buffer[firstCargo].m_nextCargo;
            if (++num2 > 0x4000)
            {
                CODebugBase<LogChannel>.Error(LogChannel.Core, "Invalid list detected!\n" + System.Environment.StackTrace);
                break;
            }
        }
        instance.ReleaseVehicle(source);
    }

    public override void UpdateBuildingTargetPositions(ushort vehicleID, ref Vehicle vehicleData, Vector3 refPos, ushort leaderID, ref Vehicle leaderData, ref int index, float minSqrDistance)
    {
        if ((leaderData.m_flags & Vehicle.Flags.WaitingTarget) == Vehicle.Flags.None)
        {
            if ((leaderData.m_flags & Vehicle.Flags.GoingBack) != Vehicle.Flags.None)
            {
                if (leaderData.m_sourceBuilding != 0)
                {
                    Vector3 vector;
                    Vector3 vector2;
                    BuildingManager instance = Singleton<BuildingManager>.instance;
                    BuildingInfo info = instance.m_buildings.m_buffer[leaderData.m_sourceBuilding].Info;
                    Randomizer randomizer = new Randomizer((int)vehicleID);
                    info.m_buildingAI.CalculateUnspawnPosition(vehicleData.m_sourceBuilding, ref instance.m_buildings.m_buffer[leaderData.m_sourceBuilding], ref randomizer, base.m_info, out vector, out vector2);
                    vehicleData.SetTargetPos(index++, base.CalculateTargetPoint(refPos, vector, minSqrDistance, 4f));
                }
            }
            else if (leaderData.m_targetBuilding != 0)
            {
                Vector3 vector3;
                Vector3 vector4;
                BuildingManager manager2 = Singleton<BuildingManager>.instance;
                BuildingInfo info2 = manager2.m_buildings.m_buffer[leaderData.m_targetBuilding].Info;
                Randomizer randomizer2 = new Randomizer((int)vehicleID);
                info2.m_buildingAI.CalculateUnspawnPosition(vehicleData.m_targetBuilding, ref manager2.m_buildings.m_buffer[leaderData.m_targetBuilding], ref randomizer2, base.m_info, out vector3, out vector4);
                vehicleData.SetTargetPos(index++, base.CalculateTargetPoint(refPos, vector3, minSqrDistance, 4f));
            }
        }
    }
}
